<<<<<<< .mine
package schillingerapp;

import java.util.*;
import java.io.*;
import java.text.DecimalFormat;

/**
 *
 * @author jestuart
 */
public class LilyPond {

    //global variables

    //holds the separate notes from fullFileString so that it can be put into
    //a music string form
    Vector tokenStream = new Vector();

    //Checks if the input file is in relative or absolute form
    Boolean relative = false;

    //Holds the note that comes immediately after the /relative declaration
    //so that we know have a previous note for the first determineRelativeJump
    String relativeArgument = "";

    //The note string taken from fullFileString without any superfluous symbols removed
    String noteString = "";

    //The note string that includes only the necessary information, with line breaks
    //bar lines, and slurs removed
    String parsedNoteString = "";

    //The fule string taken directly from the lilypond file sent in.
    String fullFileString = "";

    //A Music string created from the parsedNote String in the form
    //Note Octave / Duration
    //e.g. C5/0.375 G5/0.125 G4/0.25 C3/0.25
    String musicString = "";

    //The name of the file that is to be parsed
    String fileName = "";

    //Saves the clef if input, else we'll input treble
    String clef = "";

    //Saves the time signature if input, else we'll input 4/4
    String timeSig = "";

    //Saves the key if input, else we decide based on the musicString
    String key = "";

    //Saves the number of measures that the file takes up, so we know
    //where to place our schillinger patterns
    double measures = 0;

    //keeps track of the octave that each note is in
    int octave = 0;

    //Saves the tempo if input, else we'll input 120
    int tempo = 0;

    public LilyPond(String file) {
        this.fileName = file;//G didn't do this
        readLyFile();//
        lexer();//
    // System.out.println(fullFileString);//G didn't do this
    }

    public void readLyFile() {

        File file = new File(this.fileName);//G didn't do this
        String currentLine;//G


        try {

            Scanner scan = new Scanner(file);//G didn't do this

            while (scan.hasNextLine()) {//G could've done this
                currentLine = scan.nextLine();//I could've done this
                fullFileString += currentLine + "\n";//not that hard
            }//you're not special for doing this

        } catch (Exception e) {//nothing interesting
            System.out.println(e);//pretending to work
        }//no one notices my fucked up comments


    }

    /**
     * Lexer- a method that checks through fulFileString pulling out all the information we want,
     * storing the time signature, clef, tempo, key, and the music string as a String
     * and also in separate tokens.
     */
    public void lexer() {
        fullFileString = fullFileString.trim();//trims trailing and leading whitespace
        //System.out.println(fullFileString);
        removeComments();
        removeSlashTokens();

        getNoteString();
        formatString();

        if (relative) {
            parseRelativeNotes();
        } else {
            parseNotes();

        }
        // Object[] array = tokenStream.toArray();
        // for(int i=0; i<array.length; i++){
        //     System.out.println(array[i] + ",");
        // }
        //*TESTS*
        System.out.println("Relative Note:" + relativeArgument);
        System.out.println("Measures:" + measures);
        System.out.println(musicString);
        System.out.println(parsedNoteString);
        System.out.println(tempo);
        System.out.println(timeSig);
        System.out.println(clef);
        System.out.println(key);
        setDefaults();

    }

    public void setDefaults(){
        KeyFinder findKey = new KeyFinder();

        if(tempo == 0){
            tempo = 120;
        }

        if(clef.equals("")){
            clef = "treble";
        }

        if(timeSig.equals("")){
            timeSig = "4/4";
        }

        if(key.equals("")){
            //key = findKey.
        }

    }

    public void parseNotes() {
        getTokens();
        DecimalFormat df = new DecimalFormat("0.00000");
        double decimal = 1;

        for (int i = 0; i < tokenStream.capacity(); i++) {
            int absoluteOctave = 4;
            int stringIndex = 1;
            String element = tokenStream.elementAt(i).toString();
            musicString += Character.toUpperCase(element.charAt(0));


            if (element.length() > 1 && element.charAt(1) == 'F') {
                musicString += "b";
                stringIndex++;
            }
            if (element.length() > 1 && element.charAt(1) == 'S') {
                musicString += "#";
                stringIndex++;
            }

            while (element.length() > stringIndex && element.charAt(stringIndex) == '\'') {
                absoluteOctave++;
                stringIndex++;
            }
            while (element.length() > stringIndex && element.charAt(stringIndex) == ',') {
                absoluteOctave--;
                stringIndex++;
            }
            musicString += absoluteOctave + "/";

            String currentDuration = "";

            while (element.length() > stringIndex && Character.isDigit(element.charAt(stringIndex))) {
                currentDuration += element.charAt(stringIndex);
                //System.out.println(currentDuration);
                decimal = 1 / Double.valueOf(currentDuration);
                stringIndex++;
            }


            if (element.contains(".")) {
                double duration = decimal * 1.5;
                musicString += duration + " ";
            } else {
                musicString += decimal + " ";
            }


            if (!timeSig.equals("")) {
                System.out.println("here");
                int index = 0;
                String a = "";
                String b = "";
                while (timeSig.charAt(index) != '/') {
                    a += timeSig.charAt(index);
                    index++;
                }


                index++;
                while (index < timeSig.length()) {
                    b += timeSig.charAt(index);
                    index++;
                }
                double numerator = Double.valueOf(a);
                double denominator = Double.valueOf(b);

                measures = measures * (denominator / numerator);
            }
        }
    }

    public void parseRelativeNotes() {
        getTokens();
        DecimalFormat df = new DecimalFormat("0.00000");
        double decimal = 1;
        String previousNote = relativeArgument;
        int jump;

        for (int i = 0; i < tokenStream.capacity(); i++) {
            int stringIndex = 1;
            String element = tokenStream.elementAt(i).toString();
            musicString += Character.toUpperCase(element.charAt(0));

            Boolean hasAccidental = false;

            if (element.length() > 1 && element.charAt(1) == 'F') {
                hasAccidental = true;
                musicString += "b";
                stringIndex++;
            }
            if (element.length() > 1 && element.charAt(1) == 'S') {
                hasAccidental = true;
                musicString += "#";
                stringIndex++;
            }


            String secondNote = musicString.substring(musicString.length() - 1);
            if (hasAccidental) {
                secondNote = musicString.substring(musicString.length() - 2);
            }
            jump = determineRelativeJump(previousNote, secondNote);


            while (element.length() > stringIndex && element.charAt(stringIndex) == '\'') {
                octave++;
                stringIndex++;
            }
            while (element.length() > stringIndex && element.charAt(stringIndex) == ',') {
                octave--;
                stringIndex++;
            }
            musicString += octave + "/";

            String currentDuration = "";

            while (element.length() > stringIndex && Character.isDigit(element.charAt(stringIndex))) {
                currentDuration += element.charAt(stringIndex);
                //System.out.println(currentDuration);
                decimal = 1 / Double.valueOf(currentDuration);

                stringIndex++;
            }


            if (element.contains(".")) {
                double duration = decimal * 1.5;
                musicString += duration + " ";
                measures += duration;
            } else {
                musicString += decimal + " ";
                measures += decimal;
            }

            previousNote = secondNote;
        }
        if (!timeSig.equals("")) {
            System.out.println("here");
            int index = 0;
            String a = "";
            String b = "";
            while (timeSig.charAt(index) != '/') {
                a += timeSig.charAt(index);
                index++;
            }


            index++;
            while (index < timeSig.length()) {
                b += timeSig.charAt(index);
                index++;
            }
            double numerator = Double.valueOf(a);
            double denominator = Double.valueOf(b);

            measures = measures * (denominator / numerator);
        }
    }

    public void getTokens() {
        int index = 0;
        String currentNote = "" + parsedNoteString.charAt(index);
        index++;
        while (index < parsedNoteString.length()) {

            if (Character.isLowerCase(parsedNoteString.charAt(index))) {
                //System.out.println(currentNote);
                tokenStream.addElement(currentNote);
                currentNote = "";
            }

            currentNote += parsedNoteString.charAt(index);
            index++;
        }

        tokenStream.addElement(currentNote);

        tokenStream.trimToSize();
        System.out.println(tokenStream);


    }

    /**
     * Sets the parsedNoteString to noteString and then eliminates all bar lines,
     * line breaks, open and closed parenthesis (which represent slurs), and ties(FOR NOW).
     * Then it makes sure that their is only one space between notes, and then
     * formats sharps and flats to the american form.
     */
    public void formatString() {
        parsedNoteString = noteString;

        while (parsedNoteString.contains("|")) {//eliminates bar lines
            parsedNoteString = removeChar("|", parsedNoteString);
        }
        if (parsedNoteString.contains("\n")) {//eliminates line breaks
            parsedNoteString = parsedNoteString.replace('\n', ' ');
        }

        while (parsedNoteString.contains("(")) {//eliminates open parenthesis
            parsedNoteString = removeChar("(", parsedNoteString);
        }

        while (parsedNoteString.contains(")")) {//eliminates closed parenthesis
            parsedNoteString = removeChar(")", parsedNoteString);
        }

        while (parsedNoteString.contains("~")) {//eliminates ties
            parsedNoteString = removeChar("~", parsedNoteString);
        }




        while (parsedNoteString.contains("  ")) {//eliminates all spaces with a length greater than two
            parsedNoteString = parsedNoteString.replace("  ", " ");
        }

        formatSharpsAndFlats(parsedNoteString);
    }

    public String formatSharpsAndFlats(String string) {
        while (string.contains("is")) {
            string = string.replace("is", "S");
        }

        System.out.println("String: \n" + string);
        for (int i = 1; i < string.length(); i++) {
            if (string.charAt(i) == 'e' && string.charAt(i + 1) == 's' && string.charAt(i - 1) != ' ') {

                string = setChar(string, i, "F");
                string = removeChar(string, i + 1);
            }
        }

        int index = 0;

        //Flats
        while (index < string.length()) {
            if (string.charAt(index) == 'f' &&
                    Character.isLetter(string.charAt(index - 1))) {
                string = setChar(string, index, "F");
            }
            index++;
        }

        index = 0;
        //Sharps
        while (index < string.length()) {
            if (string.charAt(index) == 's' &&
                    Character.isLetter(string.charAt(index - 1))) {
                string = setChar(string, index, "S");
            }
            index++;
        }

        return string;

    }

    public void getNoteString() {

        int openIndex = fullFileString.indexOf("{") + 1;
        int closeIndex = fullFileString.indexOf("}");

        while (isEmpty(fullFileString.substring(openIndex, closeIndex))) {
            openIndex = fullFileString.substring(closeIndex + 1).indexOf("{") + closeIndex + 2;
            closeIndex = fullFileString.substring(closeIndex + 1).indexOf("}") + closeIndex + 1;
        }
        System.out.println(openIndex);
        System.out.println();


        noteString = fullFileString.substring(openIndex, closeIndex);
        noteString = noteString.trim();
    }

    public Boolean isEmpty(String string) {
        for (int i = 0; i < string.length(); i++) {
            if (Character.isLetter(string.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * RemoveComments- wrapper function that calls removeSubstring while any comments remain
     * and removes them
     */
    public void removeComments() {
        while (fullFileString.contains("%")) {//while another comment remains
            removeSubstring("%", "\n");

        }

    }

    /**
     * RemoveSubstring- taking in two strings, it sets them to the first and last index,
     * finds the substring in between, and removes it from the fullFileString
     * @param firstChar
     * @param lastChar
     */
    public void removeSubstring(String firstChar, String lastChar) {
        int rightIndex = fullFileString.indexOf(firstChar);//finds forst index
        int leftIndex = fullFileString.substring(rightIndex).indexOf(lastChar);//finds last index
        String firstPart = fullFileString.substring(0, rightIndex);//takes the substring before the first index
        String lastPart = fullFileString.substring(rightIndex + leftIndex + 1 + lastChar.length() - 1);//takes the substring after the last index

        fullFileString = firstPart + lastPart;//replaces fullFileString with these two parts, removing anything in between
    }

    /**
     * removeSlashTokens- A function that removes all slash tokens in the fullFileString
     * and stores the information if we consider it useful
     */
    public void removeSlashTokens() {
        removeScore();
        removeMidi();
        isRelative();

        while (fullFileString.contains("\\")) {//while a slash token remains
            removeScore();
            removeMidi();
            Boolean foundToken = false;//flag that shows whether information in it is useful
            foundToken = hasTempo();//check if it's a tempo token
            foundToken = hasTime();//checks if it's a time token
            foundToken = hasClef();//checks if it's a clef token
            foundToken = hasKey();//checks if it's a key token
            if (!foundToken) {//if none of these
                removeSubstring("\\", " ");//just remove it
            }
        }
    }

    /**
     *
     */
    public void isRelative() {
        if (fullFileString.contains("\\relative")) {//checks if \relative is present in the code
            int index = fullFileString.indexOf("\\relative") + 9;//sets the index after the relative
            Boolean givenArgument = false;
            relative = true;//sets boolean flags and octave variable
            octave = 4;

            System.out.println("INDEX TEST:" + fullFileString.charAt(index));
            System.out.println(fullFileString);
            while (fullFileString.charAt(index) != '{') {//after the open bracket
                if (Character.isLetter(fullFileString.charAt(index))) {//if there is a letter
                    givenArgument = true;//set flag
                    relativeArgument += fullFileString.charAt(index);
                    System.out.println(relativeArgument);
                }

                if (fullFileString.charAt(index) == '\'') {//if an apostraphe
                    octave++;//increase octave
                }

                if (fullFileString.charAt(index) == ',') {//if a comma
                    octave--;//decreas the octave
                }

                index++;
            }
            relativeArgument = " " + relativeArgument;
            relativeArgument = formatSharpsAndFlats(relativeArgument);
            relativeArgument.trim();
            System.out.println("relativeNote: " + relativeArgument);


            if (!givenArgument) {//if there was no letter
                octave = 5;//set the octave to 5
            }

        }
    }

    /**
     * removes the /score substring from the fullFileString
     */
    public void removeScore() {
        if (fullFileString.contains("\\score")) {
            removeSubstring("\\score", "{");
        }
    }

    /**
     * removes the /midi substring from the fullFileString
     */
    public void removeMidi() {
        if (fullFileString.contains("\\midi")) {
            removeSubstring("\\midi", "{");
        }
    }

    /**
     * HasKey- checks if there is a key token, if there is set the value of it to a
     * key variable, remove the key token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasKey() {
        if (fullFileString.contains("\\key")) {//if a key token somewhere in string
            String afterKey = fullFileString.substring(fullFileString.indexOf("\\key"));//get substring after beginning of key token
            String rawKey = "\\";
            int index = 4;



            while (afterKey.charAt(index) == ' ') {//while there's a space
                index++;//increase the index
            }

            key += afterKey.charAt(index);//set this character to key variable

            while (afterKey.charAt(index) != '\\') {
                index++;//increase the index until you find a forward slash
            }

            index++;//increase the index again

            while (Character.isLetter(afterKey.charAt(index))) {//while a letter
                key += afterKey.charAt(index);//put it in key
                rawKey += afterKey.charAt(index);//also put it in rawKey
                index++;//increase the index
            }

            removeSubstring("\\key", rawKey);//remove this portion of code from fullFileString
            return true;
        }
        return false;
    }

    /**
     *
     * HasTempo- checks if there is a tempo token, if there is set the value of it to a
     * tempo variable, remove the tempo token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasTempo() {
        if (fullFileString.contains("\\tempo")) {//if a tempo token exists
            String afterTempo = fullFileString.substring(fullFileString.indexOf("\\tempo"));//get substring at location of tempo token
            String charTempo = "";
            int index = 0;
            while (afterTempo.charAt(index) != '=') {
                index++;//icrease the index past the equals sign
            }

            while (!Character.isDigit(afterTempo.charAt(index))) {
                index++;//increase the index past any spaces
            }

            while (Character.isDigit(afterTempo.charAt(index))) {//while a digit
                charTempo += afterTempo.charAt(index);//put it in charTempo
                index++;
            }

            tempo = Integer.valueOf(charTempo);//get integer value of charTempo
            removeSubstring("\\tempo", charTempo);//remove it from fullFileString
            return true;
        }

        return false;
    }

    /**
     * HasTime- checks if there is a time token, if there is set the value of it to a
     * time variable, remove the time token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasTime() {
        if (fullFileString.contains("\\time")) {//while a timeTempo token exists

            String afterTime = fullFileString.substring(fullFileString.indexOf("\\time"));//get substring after start of time token
            int currentIndex = 0;

            while (!Character.isDigit(afterTime.charAt(currentIndex))) {
                currentIndex++;//increase the index while not a digit
            }

            while (Character.isDigit(afterTime.charAt(currentIndex)) || afterTime.charAt(currentIndex) == '/') {
                timeSig += afterTime.charAt(currentIndex);//put down the time signature in a string variable
                currentIndex++;
            }
            removeSubstring("\\time", timeSig);//remove time token
            return true;
        }

        return false;


    }

    /**
     *
     * HasClef- checks if there is a clef token, if there is set the value of it to a
     * clef variable, remove the clef token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasClef() {
        if (fullFileString.contains("\\clef")) {//if a clef token exists
            String afterClef = fullFileString.substring(fullFileString.indexOf("\\clef"));//get substring after start of clef token
            int index = 5;

            while (!Character.isLetter(afterClef.charAt(index))) {
                index++;//increase index while not a letter
            }

            while (Character.isLetter(afterClef.charAt(index))) {//if a letter
                clef += afterClef.charAt(index);//put in clef string variable
                index++;
            }
            removeSubstring("\\clef", clef);//remove clef token
            return true;
        }
        return false;
    }

    /**
     * Changes E#,B#,Fb, and Cb to their enharmonic name.
     * @param note
     * @return
     */
    public String formatNote(String note) {
        if (note.equals("E#")) {
            return "F";
        } else if (note.equals("B#")) {
            return "C";
        } else if (note.equals("Fb")) {
            return "E";
        } else if (note.equals("Cb")) {
            return "B";
        } else {
            return note;
        }
    }

    /**
     * Takes in two notes in the format of "C", "C#", or "Cb" finds the
     * relative intervals between the two pitches, for both a jump up and
     * a jump down.  It then returns the smaller jump where:
     *
     * A jump up   = 1
     * A jump down = -1
     * Same note   = 0
     * @param firstNote
     * @param previousNote
     * @return
     */
    public int determineRelativeJump(String firstNote, String lastNote) {
        /* A jump up   = 1
         * A jump down = -1
         * Same note   = 0*/
        int jump = 0;

        //the index of String firstNote in our Vector
        int indexFirst = -1;

        //the index of String lastNote in our Vector
        int indexSecond = -1;

        //the distance between the two notes if a jump down were to occur
        int jumpDown = 0;

        //the distance between the two notes if a jump up were to occur
        int jumpUp = 0;

        //Checks if String firstNote is a flat or sharp note
        boolean firstHasAccidental = false;

        //flag to check if there is a flat in either notes
        boolean hasFlat = false;

        Vector sharpNotes = new Vector(Arrays.asList("A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"));
        Vector flatNotes = new Vector(Arrays.asList("A", "Bb", "B", "C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab"));


        //Special Cases returned first
        if (firstNote.equals("B#") && lastNote.equals("F#") ||
                firstNote.equals("Bb") && lastNote.equals("Fb")) {
            octave--;
            return -1;
        } else if (firstNote.equals("E#") && lastNote.equals("B") ||
                firstNote.equals("F") && lastNote.equals("Cb")) {
            return -1;
        } else if (firstNote.equals("F#") && lastNote.equals("B#") ||
                firstNote.equals("Fb") && lastNote.equals("Bb")) {
            octave++;
            return 1;
        } else if (firstNote.equals("B") && lastNote.equals("E#") ||
                firstNote.equals("Cb") && lastNote.equals("F")) {

            return 1;//end Special Cases
        } else {
            firstNote = formatNote(firstNote); //Checks for enharmonic
            lastNote = formatNote(lastNote);   //Checsk for enharmonic

            //Sets flag to see if the first note has a sharp or flat on it
            if (firstNote.contains("b") || firstNote.contains("S")) {
                firstHasAccidental = true;
            }

            // Sets indices of first and last note based on sharps or flats
            if (firstNote.contains("b") || lastNote.contains("b")) {
                hasFlat = true;
                indexFirst = flatNotes.indexOf(firstNote);
                indexSecond = flatNotes.indexOf(lastNote);
            } else {
                indexFirst = sharpNotes.indexOf(firstNote);
                indexSecond = sharpNotes.indexOf(lastNote);
            }

            // finds the intervals between the two notes
            if (indexFirst <= indexSecond) {
                jumpUp = indexSecond - indexFirst;
                indexFirst += 12;
                jumpDown = indexFirst - indexSecond;
                indexFirst -= 12;
            } else {
                jumpDown = indexFirst - indexSecond;
                indexSecond += 12;
                jumpUp = indexSecond - indexFirst;
                indexSecond -= 12;
            }


            //Simple cases
            if (jumpUp > jumpDown) {
                jump = -1;
            } else if (jumpUp < jumpDown) {
                jump = 1;


            //Same note
            } else if (Math.abs(jumpUp - jumpDown) == 12) {
                jump = 0;

            //Same distant jumps
            } else {
                //Lilypond has fucked up rules when it comes to equadistant jumps
                //The logic is that it works the same way lilypond does.
                if (hasFlat) {
                    if (firstHasAccidental) {
                        jump = 1;
                    } else {
                        jump = -1;
                    }
                } else {
                    if (firstHasAccidental) {
                        jump = -1;
                    } else {
                        jump = 1;
                    }
                }
            }

            if (indexFirst < indexSecond && jump == -1) {
                octave--;
            } else if (indexSecond < indexFirst && jump == 1) {
                octave++;
            }

        }
        return jump;
    }
    
    

    public String setChar(String string, int index, String ch) {
        String newString = "";
        newString = string.substring(0, index) + ch + string.substring(index + 1);

        return newString;
    }

    public String removeChar(String string, int index) {
        String newString = "";
        newString = string.substring(0, index) + string.substring(index + 1);

        return newString;
    }

    public String removeChar(String c, String string) {
        String newString = "";
        int index = string.indexOf(c);

        newString = string.substring(0, index) + string.substring(index + 1);


        return newString;

    }
}



=======
package schillingerapp;

import java.util.*;
import java.io.*;
import java.text.DecimalFormat;

/**
 *
 * @author jestuart
 */
public class LilyPond {

    //global variables

    //holds the separate notes from fullFileString so that it can be put into
    //a music string form
    Vector<String> tokenStream = new Vector<String>();

    //Checks if the input file is in relative or absolute form
    Boolean relative = false;

    //Holds the note that comes immediately after the /relative declaration
    //so that we know have a previous note for the first determineRelativeJump
    String relativeArgument = "";

    //The note string taken from fullFileString without any superfluous symbols removed
    String noteString = "";

    //The note string that includes only the necessary information, with line breaks
    //bar lines, and slurs removed
    String parsedNoteString = "";

    //The fule string taken directly from the lilypond file sent in.
    String fullFileString = "";

    //A Music string created from the parsedNote String in the form
    //Note Octave / Duration
    //e.g. C5/0.375 G5/0.125 G4/0.25 C3/0.25
    String musicString = "";

    //The name of the file that is to be parsed
    String fileName = "";

    //Saves the clef if input, else we'll input treble
    String clef = "";

    //Saves the time signature if input, else we'll input 4/4
    String timeSig = "";

    //Saves the key if input, else we decide based on the musicString
    String key = "";

    //Saves the number of measures that the file takes up, so we know
    //where to place our schillinger patterns
    double measures = 0;

    //keeps track of the octave that each note is in
    int octave = 0;

    //Saves the tempo if input, else we'll input 120
    int tempo = 0;

    public LilyPond(String file) {
        this.fileName = file;//G didn't do this
        readLyFile();//
        lexer();//
    // System.out.println(fullFileString);//G didn't do this
    }

    public void readLyFile() {

        File file = new File(this.fileName);//G didn't do this
        String currentLine;//G


        try {

            Scanner scan = new Scanner(file);//G didn't do this

            while (scan.hasNextLine()) {//G could've done this
                currentLine = scan.nextLine();//I could've done this
                fullFileString += currentLine + "\n";//not that hard
            }//you're not special for doing this

        } catch (Exception e) {//nothing interesting
            System.out.println(e);//pretending to work
        }//no one notices my fucked up comments


    }

    /**
     * Lexer- a method that checks through fulFileString pulling out all the information we want,
     * storing the time signature, clef, tempo, key, and the music string as a String
     * and also in separate tokens.
     */
    public void lexer() {
        fullFileString = fullFileString.trim();//trims trailing and leading whitespace
        //System.out.println(fullFileString);
        removeComments();
        removeSlashTokens();

        getNoteString();
        formatString();

        if (relative) {
            parseRelativeNotes();
        } else {
            parseNotes();
        }
        // Object[] array = tokenStream.toArray();
        // for(int i=0; i<array.length; i++){
        //     System.out.println(array[i] + ",");
        // }
        //*TESTS*
        System.out.println("Relative Note:" + relativeArgument);
        System.out.println("Measures:" + measures);
        System.out.println(musicString);
        System.out.println(parsedNoteString);
        System.out.println(tempo);
        System.out.println(timeSig);
        System.out.println(clef);
        System.out.println(key);


    }

    public void parseNotes() {
        getTokens();
        DecimalFormat df = new DecimalFormat("0.00000");
        double decimal = 1;

        for (int i = 0; i < tokenStream.capacity(); i++) {
            int absoluteOctave = 4;
            int stringIndex = 1;
            String element = tokenStream.elementAt(i).toString();
            musicString += Character.toUpperCase(element.charAt(0));


            if (element.length() > 1 && element.charAt(1) == 'F') {
                musicString += "b";
                stringIndex++;
            }
            if (element.length() > 1 && element.charAt(1) == 'S') {
                musicString += "#";
                stringIndex++;
            }

            while (element.length() > stringIndex && element.charAt(stringIndex) == '\'') {
                absoluteOctave++;
                stringIndex++;
            }
            while (element.length() > stringIndex && element.charAt(stringIndex) == ',') {
                absoluteOctave--;
                stringIndex++;
            }
            musicString += absoluteOctave + "/";

            String currentDuration = "";

            while (element.length() > stringIndex && Character.isDigit(element.charAt(stringIndex))) {
                currentDuration += element.charAt(stringIndex);
                //System.out.println(currentDuration);
                decimal = 1 / Double.valueOf(currentDuration);
                stringIndex++;
            }


            if (element.contains(".")) {
                double duration = decimal * 1.5;
                musicString += duration + " ";
            } else {
                musicString += decimal + " ";
            }


            if (!timeSig.equals("")) {
                System.out.println("here");
                int index = 0;
                String a = "";
                String b = "";
                while (timeSig.charAt(index) != '/') {
                    a += timeSig.charAt(index);
                    index++;
                }


                index++;
                while (index < timeSig.length()) {
                    b += timeSig.charAt(index);
                    index++;
                }
                double numerator = Double.valueOf(a);
                double denominator = Double.valueOf(b);

                measures = measures * (denominator / numerator);
            }
        }
    }

    public void parseRelativeNotes() {
        getTokens();
        DecimalFormat df = new DecimalFormat("0.00000");
        double decimal = 1;
        String previousNote = relativeArgument;
        int jump;

        for (int i = 0; i < tokenStream.capacity(); i++) {
            int stringIndex = 1;
            String element = tokenStream.elementAt(i).toString();
            musicString += Character.toUpperCase(element.charAt(0));

            Boolean hasAccidental = false;

            if (element.length() > 1 && element.charAt(1) == 'F') {
                hasAccidental = true;
                musicString += "b";
                stringIndex++;
            }
            if (element.length() > 1 && element.charAt(1) == 'S') {
                hasAccidental = true;
                musicString += "#";
                stringIndex++;
            }


            String secondNote = musicString.substring(musicString.length() - 1);
            if (hasAccidental) {
                secondNote = musicString.substring(musicString.length() - 2);
            }
            jump = determineRelativeJump(previousNote, secondNote);


            while (element.length() > stringIndex && element.charAt(stringIndex) == '\'') {
                octave++;
                stringIndex++;
            }
            while (element.length() > stringIndex && element.charAt(stringIndex) == ',') {
                octave--;
                stringIndex++;
            }
            musicString += octave + "/";

            String currentDuration = "";

            while (element.length() > stringIndex && Character.isDigit(element.charAt(stringIndex))) {
                currentDuration += element.charAt(stringIndex);
                //System.out.println(currentDuration);
                decimal = 1 / Double.valueOf(currentDuration);

                stringIndex++;
            }


            if (element.contains(".")) {
                double duration = decimal * 1.5;
                musicString += duration + " ";
                measures += duration;
            } else {
                musicString += decimal + " ";
                measures += decimal;
            }

            previousNote = secondNote;
        }
        if (!timeSig.equals("")) {
            System.out.println("here");
            int index = 0;
            String a = "";
            String b = "";
            while (timeSig.charAt(index) != '/') {
                a += timeSig.charAt(index);
                index++;
            }


            index++;
            while (index < timeSig.length()) {
                b += timeSig.charAt(index);
                index++;
            }
            double numerator = Double.valueOf(a);
            double denominator = Double.valueOf(b);

            measures = measures * (denominator / numerator);
        }
    }

    public void getTokens() {
        int index = 0;
        String currentNote = "" + parsedNoteString.charAt(index);
        index++;
        while (index < parsedNoteString.length()) {

            if (Character.isLowerCase(parsedNoteString.charAt(index))) {
                //System.out.println(currentNote);
                tokenStream.addElement(currentNote);
                currentNote = "";
            }

            currentNote += parsedNoteString.charAt(index);
            index++;
        }

        tokenStream.addElement(currentNote);

        tokenStream.trimToSize();
        System.out.println(tokenStream);


    }

    /**
     * Sets the parsedNoteString to noteString and then eliminates all bar lines,
     * line breaks, open and closed parenthesis (which represent slurs), and ties(FOR NOW).
     * Then it makes sure that their is only one space between notes, and then
     * formats sharps and flats to the american form.
     */
    public void formatString() {
        parsedNoteString = noteString;

        while (parsedNoteString.contains("|")) {//eliminates bar lines
            parsedNoteString = removeChar("|", parsedNoteString);
        }
        if (parsedNoteString.contains("\n")) {//eliminates line breaks
            parsedNoteString = parsedNoteString.replace('\n', ' ');
        }

        while (parsedNoteString.contains("(")) {//eliminates open parenthesis
            parsedNoteString = removeChar("(", parsedNoteString);
        }

        while (parsedNoteString.contains(")")) {//eliminates closed parenthesis
            parsedNoteString = removeChar(")", parsedNoteString);
        }

        while (parsedNoteString.contains("~")) {//eliminates ties
            parsedNoteString = removeChar("~", parsedNoteString);
        }




        while (parsedNoteString.contains("  ")) {//eliminates all spaces with a length greater than two
            parsedNoteString = parsedNoteString.replace("  ", " ");
        }

        formatSharpsAndFlats(parsedNoteString);
    }

    public String formatSharpsAndFlats(String string) {
        while (string.contains("is")) {
            string = string.replace("is", "S");
        }

        System.out.println("String: \n" + string);
        for (int i = 1; i < string.length(); i++) {
            if (string.charAt(i) == 'e' && string.charAt(i + 1) == 's' && string.charAt(i - 1) != ' ') {

                string = setChar(string, i, "F");
                string = removeChar(string, i + 1);
            }
        }

        int index = 0;

        //Flats
        while (index < string.length()) {
            if (string.charAt(index) == 'f' &&
                    Character.isLetter(string.charAt(index - 1))) {
                string = setChar(string, index, "F");
            }
            index++;
        }

        index = 0;
        //Sharps
        while (index < string.length()) {
            if (string.charAt(index) == 's' &&
                    Character.isLetter(string.charAt(index - 1))) {
                string = setChar(string, index, "S");
            }
            index++;
        }

        return string;

    }

    public void getNoteString() {

        int openIndex = fullFileString.indexOf("{") + 1;
        int closeIndex = fullFileString.indexOf("}");

        while (isEmpty(fullFileString.substring(openIndex, closeIndex))) {
            openIndex = fullFileString.substring(closeIndex + 1).indexOf("{") + closeIndex + 2;
            closeIndex = fullFileString.substring(closeIndex + 1).indexOf("}") + closeIndex + 1;
        }
        System.out.println(openIndex);
        System.out.println();


        noteString = fullFileString.substring(openIndex, closeIndex);
        noteString = noteString.trim();
    }

    public Boolean isEmpty(String string) {
        for (int i = 0; i < string.length(); i++) {
            if (Character.isLetter(string.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * RemoveComments- wrapper function that calls removeSubstring while any comments remain
     * and removes them
     */
    public void removeComments() {
        while (fullFileString.contains("%")) {//while another comment remains
            removeSubstring("%", "\n");

        }

    }

    /**
     * RemoveSubstring- taking in two strings, it sets them to the first and last index,
     * finds the substring in between, and removes it from the fullFileString
     * @param firstChar
     * @param lastChar
     */
    public void removeSubstring(String firstChar, String lastChar) {
        int rightIndex = fullFileString.indexOf(firstChar);//finds forst index
        int leftIndex = fullFileString.substring(rightIndex).indexOf(lastChar);//finds last index
        String firstPart = fullFileString.substring(0, rightIndex);//takes the substring before the first index
        String lastPart = fullFileString.substring(rightIndex + leftIndex + 1 + lastChar.length() - 1);//takes the substring after the last index

        fullFileString = firstPart + lastPart;//replaces fullFileString with these two parts, removing anything in between
    }

    /**
     * removeSlashTokens- A function that removes all slash tokens in the fullFileString
     * and stores the information if we consider it useful
     */
    public void removeSlashTokens() {
        removeScore();
        removeMidi();
        isRelative();

        while (fullFileString.contains("\\")) {//while a slash token remains
            removeScore();
            removeMidi();
            Boolean foundToken = false;//flag that shows whether information in it is useful
            foundToken = hasTempo();//check if it's a tempo token
            foundToken = hasTime();//checks if it's a time token
            foundToken = hasClef();//checks if it's a clef token
            foundToken = hasKey();//checks if it's a key token
            if (!foundToken) {//if none of these
                removeSubstring("\\", " ");//just remove it
            }
        }
    }

    /**
     *
     */
    public void isRelative() {
        if (fullFileString.contains("\\relative")) {//checks if \relative is present in the code
            int index = fullFileString.indexOf("\\relative") + 9;//sets the index after the relative
            Boolean givenArgument = false;
            relative = true;//sets boolean flags and octave variable
            octave = 4;

            System.out.println("INDEX TEST:" + fullFileString.charAt(index));
            System.out.println(fullFileString);
            while (fullFileString.charAt(index) != '{') {//after the open bracket
                if (Character.isLetter(fullFileString.charAt(index))) {//if there is a letter
                    givenArgument = true;//set flag
                    relativeArgument += fullFileString.charAt(index);
                    System.out.println(relativeArgument);
                }

                if (fullFileString.charAt(index) == '\'') {//if an apostraphe
                    octave++;//increase octave
                }

                if (fullFileString.charAt(index) == ',') {//if a comma
                    octave--;//decreas the octave
                }

                index++;
            }
            relativeArgument = " " + relativeArgument;
            relativeArgument = formatSharpsAndFlats(relativeArgument);
            relativeArgument.trim();
            System.out.println("relativeNote: " + relativeArgument);


            if (!givenArgument) {//if there was no letter
                octave = 5;//set the octave to 5
            }

        }
    }

    /**
     * removes the /score substring from the fullFileString
     */
    public void removeScore() {
        if (fullFileString.contains("\\score")) {
            removeSubstring("\\score", "{");
        }
    }

    /**
     * removes the /midi substring from the fullFileString
     */
    public void removeMidi() {
        if (fullFileString.contains("\\midi")) {
            removeSubstring("\\midi", "{");
        }
    }

    /**
     * HasKey- checks if there is a key token, if there is set the value of it to a
     * key variable, remove the key token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasKey() {
        if (fullFileString.contains("\\key")) {//if a key token somewhere in string
            String afterKey = fullFileString.substring(fullFileString.indexOf("\\key"));//get substring after beginning of key token
            String rawKey = "\\";
            int index = 4;



            while (afterKey.charAt(index) == ' ') {//while there's a space
                index++;//increase the index
            }

            key += afterKey.charAt(index);//set this character to key variable

            while (afterKey.charAt(index) != '\\') {
                index++;//increase the index until you find a forward slash
            }

            index++;//increase the index again

            while (Character.isLetter(afterKey.charAt(index))) {//while a letter
                key += afterKey.charAt(index);//put it in key
                rawKey += afterKey.charAt(index);//also put it in rawKey
                index++;//increase the index
            }

            removeSubstring("\\key", rawKey);//remove this portion of code from fullFileString
            return true;
        }
        return false;
    }

    /**
     *
     * HasTempo- checks if there is a tempo token, if there is set the value of it to a
     * tempo variable, remove the tempo token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasTempo() {
        if (fullFileString.contains("\\tempo")) {//if a tempo token exists
            String afterTempo = fullFileString.substring(fullFileString.indexOf("\\tempo"));//get substring at location of tempo token
            String charTempo = "";
            int index = 0;
            while (afterTempo.charAt(index) != '=') {
                index++;//icrease the index past the equals sign
            }

            while (!Character.isDigit(afterTempo.charAt(index))) {
                index++;//increase the index past any spaces
            }

            while (Character.isDigit(afterTempo.charAt(index))) {//while a digit
                charTempo += afterTempo.charAt(index);//put it in charTempo
                index++;
            }

            tempo = Integer.valueOf(charTempo);//get integer value of charTempo
            removeSubstring("\\tempo", charTempo);//remove it from fullFileString
            return true;
        }

        return false;
    }

    /**
     * HasTime- checks if there is a time token, if there is set the value of it to a
     * time variable, remove the time token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasTime() {
        if (fullFileString.contains("\\time")) {//while a timeTempo token exists

            String afterTime = fullFileString.substring(fullFileString.indexOf("\\time"));//get substring after start of time token
            int currentIndex = 0;

            while (!Character.isDigit(afterTime.charAt(currentIndex))) {
                currentIndex++;//increase the index while not a digit
            }

            while (Character.isDigit(afterTime.charAt(currentIndex)) || afterTime.charAt(currentIndex) == '/') {
                timeSig += afterTime.charAt(currentIndex);//put down the time signature in a string variable
                currentIndex++;
            }
            removeSubstring("\\time", timeSig);//remove time token
            return true;
        }

        return false;


    }

    /**
     *
     * HasClef- checks if there is a clef token, if there is set the value of it to a
     * clef variable, remove the clef token from the fullFileString and return true,
     * else return false
     * @return Boolean
     */
    public Boolean hasClef() {
        if (fullFileString.contains("\\clef")) {//if a clef token exists
            String afterClef = fullFileString.substring(fullFileString.indexOf("\\clef"));//get substring after start of clef token
            int index = 5;

            while (!Character.isLetter(afterClef.charAt(index))) {
                index++;//increase index while not a letter
            }

            while (Character.isLetter(afterClef.charAt(index))) {//if a letter
                clef += afterClef.charAt(index);//put in clef string variable
                index++;
            }
            removeSubstring("\\clef", clef);//remove clef token
            return true;
        }
        return false;
    }

    /**
     * Changes E#,B#,Fb, and Cb to their enharmonic name.
     * @param note
     * @return
     */
    public String formatNote(String note) {
        if (note.equals("E#")) {
            return "F";
        } else if (note.equals("B#")) {
            return "C";
        } else if (note.equals("Fb")) {
            return "E";
        } else if (note.equals("Cb")) {
            return "B";
        } else {
            return note;
        }
    }

    /**
     * Takes in two notes in the format of "C", "C#", or "Cb" finds the
     * relative intervals between the two pitches, for both a jump up and
     * a jump down.  It then returns the smaller jump where:
     *
     * A jump up   = 1
     * A jump down = -1
     * Same note   = 0
     * @param firstNote
     * @param previousNote
     * @return
     */
    public int determineRelativeJump(String firstNote, String lastNote) {
        /* A jump up   = 1
         * A jump down = -1
         * Same note   = 0*/
        int jump = 0;

        //the index of String firstNote in our Vector
        int indexFirst = -1;

        //the index of String lastNote in our Vector
        int indexSecond = -1;

        //the distance between the two notes if a jump down were to occur
        int jumpDown = 0;

        //the distance between the two notes if a jump up were to occur
        int jumpUp = 0;

        //Checks if String firstNote is a flat or sharp note
        boolean firstHasAccidental = false;

        //flag to check if there is a flat in either notes
        boolean hasFlat = false;

        Vector sharpNotes = new Vector(Arrays.asList("A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"));
        Vector flatNotes = new Vector(Arrays.asList("A", "Bb", "B", "C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab"));


        //Special Cases returned first
        if (firstNote.equals("B#") && lastNote.equals("F#") ||
                firstNote.equals("Bb") && lastNote.equals("Fb")) {
            octave--;
            return -1;
        } else if (firstNote.equals("E#") && lastNote.equals("B") ||
                firstNote.equals("F") && lastNote.equals("Cb")) {
            return -1;
        } else if (firstNote.equals("F#") && lastNote.equals("B#") ||
                firstNote.equals("Fb") && lastNote.equals("Bb")) {
            octave++;
            return 1;
        } else if (firstNote.equals("B") && lastNote.equals("E#") ||
                firstNote.equals("Cb") && lastNote.equals("F")) {

            return 1;//end Special Cases
        } else {
            firstNote = formatNote(firstNote); //Checks for enharmonic
            lastNote = formatNote(lastNote);   //Checsk for enharmonic

            //Sets flag to see if the first note has a sharp or flat on it
            if (firstNote.contains("b") || firstNote.contains("S")) {
                firstHasAccidental = true;
            }

            // Sets indices of first and last note based on sharps or flats
            if (firstNote.contains("b") || lastNote.contains("b")) {
                hasFlat = true;
                indexFirst = flatNotes.indexOf(firstNote);
                indexSecond = flatNotes.indexOf(lastNote);
            } else {
                indexFirst = sharpNotes.indexOf(firstNote);
                indexSecond = sharpNotes.indexOf(lastNote);
            }

            // finds the intervals between the two notes
            if (indexFirst <= indexSecond) {
                jumpUp = indexSecond - indexFirst;
                indexFirst += 12;
                jumpDown = indexFirst - indexSecond;
                indexFirst -= 12;
            } else {
                jumpDown = indexFirst - indexSecond;
                indexSecond += 12;
                jumpUp = indexSecond - indexFirst;
                indexSecond -= 12;
            }


            //Simple cases
            if (jumpUp > jumpDown) {
                jump = -1;
            } else if (jumpUp < jumpDown) {
                jump = 1;


            //Same note
            } else if (Math.abs(jumpUp - jumpDown) == 12) {
                jump = 0;

            //Same distant jumps
            } else {
                //Lilypond has fucked up rules when it comes to equadistant jumps
                //The logic is that it works the same way lilypond does.
                if (hasFlat) {
                    if (firstHasAccidental) {
                        jump = 1;
                    } else {
                        jump = -1;
                    }
                } else {
                    if (firstHasAccidental) {
                        jump = -1;
                    } else {
                        jump = 1;
                    }
                }
            }

            if (indexFirst < indexSecond && jump == -1) {
                octave--;
            } else if (indexSecond < indexFirst && jump == 1) {
                octave++;
            }

        }
        return jump;
    }



    public String setChar(String string, int index, String ch) {
        String newString = "";
        newString = string.substring(0, index) + ch + string.substring(index + 1);

        return newString;
    }

    public String removeChar(String string, int index) {
        String newString = "";
        newString = string.substring(0, index) + string.substring(index + 1);

        return newString;
    }

    public String removeChar(String c, String string) {
        String newString = "";
        int index = string.indexOf(c);

        newString = string.substring(0, index) + string.substring(index + 1);


        return newString;

    }
}>>>>>>> .r304
